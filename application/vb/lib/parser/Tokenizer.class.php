<?php

// Generated by Haxe 3.4.2
class parser_Tokenizer extends util_ReadStream {
	public function __construct($src = null) {
		if(!php_Boot::$skip_constructor) {
		if($src === null) {
			$src = "";
		}
		parent::__construct($src);
		$this->reset();
		$this->advance();
	}}
	public $buf;
	public function atEnd() {
		$this->skipWhitespace();
		return $this->atEof();
	}
	public function nextToken() {
		$this->reset();
		$this->skipWhitespace();
		if($this->isLetter(null)) {
			return $this->readId();
		} else {
			if($this->isDigit(null)) {
				return $this->readInt();
			} else {
				if($this->isDquote(null)) {
					return $this->readString();
				} else {
					if($this->isSquote(null)) {
						return $this->readComment();
					} else {
						$token = $this->readDouble();
						if($token !== null) {
							return $token;
						} else {
							return $this->readSingle();
						}
					}
				}
			}
		}
	}
	public function createToken($val, $type) {
		return new parser_Token($val, $type);
	}
	public function createIdToken($val) {
		return $this->createToken($val, constants_TokenType::$Id);
	}
	public function createKeywordToken($val) {
		$lcval = strtolower($val);
		switch($lcval) {
		case "as":{
			return $this->createToken($lcval, constants_TokenType::$KwAs);
		}break;
		case "basiceditor":{
			return $this->createToken($lcval, constants_TokenType::$KwBasicEditor);
		}break;
		case "button":{
			return $this->createToken($lcval, constants_TokenType::$KwButton);
		}break;
		case "database":{
			return $this->createToken($lcval, constants_TokenType::$KwDatabase);
		}break;
		case "dim":{
			return $this->createToken($lcval, constants_TokenType::$KwDim);
		}break;
		case "do":{
			return $this->createToken($lcval, constants_TokenType::$KwDo);
		}break;
		case "else":{
			return $this->createToken($lcval, constants_TokenType::$KwElse);
		}break;
		case "elseif":{
			return $this->createToken($lcval, constants_TokenType::$KwElseIf);
		}break;
		case "end":{
			return $this->createToken($lcval, constants_TokenType::$KwEnd);
		}break;
		case "formpanel":{
			return $this->createToken($lcval, constants_TokenType::$KwFormPanel);
		}break;
		case "hsplitpanel":{
			return $this->createToken($lcval, constants_TokenType::$KwHSplitPanel);
		}break;
		case "if":{
			return $this->createToken($lcval, constants_TokenType::$KwIf);
		}break;
		case "listpanel":{
			return $this->createToken($lcval, constants_TokenType::$KwListPanel);
		}break;
		case "richeditor":{
			return $this->createToken($lcval, constants_TokenType::$KwRichEditor);
		}break;
		case "sub":{
			return $this->createToken($lcval, constants_TokenType::$KwSub);
		}break;
		case "tabpanel":{
			return $this->createToken($lcval, constants_TokenType::$KwTabPanel);
		}break;
		case "textarea":{
			return $this->createToken($lcval, constants_TokenType::$KwTextArea);
		}break;
		case "textfield":{
			return $this->createToken($lcval, constants_TokenType::$KwTextField);
		}break;
		case "then":{
			return $this->createToken($lcval, constants_TokenType::$KwThen);
		}break;
		case "until":{
			return $this->createToken($lcval, constants_TokenType::$KwUntil);
		}break;
		case "viewport":{
			return $this->createToken($lcval, constants_TokenType::$KwViewport);
		}break;
		case "vsplitpanel":{
			return $this->createToken($lcval, constants_TokenType::$KwVSplitPanel);
		}break;
		case "wend":{
			return $this->createToken($lcval, constants_TokenType::$KwWend);
		}break;
		case "while":{
			return $this->createToken($lcval, constants_TokenType::$KwWhile);
		}break;
		case "window":{
			return $this->createToken($lcval, constants_TokenType::$KwWindow);
		}break;
		default:{
			return null;
		}break;
		}
	}
	public function readComment() {
		while(!$this->isEol()) {
			$this->buf->add($this->ch);
			$this->advance();
		}
		return $this->createToken($this->buf->b, constants_TokenType::$Comment);
	}
	public function readId() {
		while($this->isIdCh(null)) {
			$this->buf->add($this->ch);
			$this->advance();
		}
		$id = $this->buf->b;
		$token = $this->createKeywordToken($id);
		if($token !== null) {
			return $token;
		} else {
			return $this->createIdToken($id);
		}
	}
	public function readInt() {
		while($this->isDigit(null)) {
			$this->buf->add($this->ch);
			$this->advance();
		}
		return $this->createToken($this->buf->b, constants_TokenType::$Int);
	}
	public function readString() {
		$this->advance();
		while($this->isStringCh(null)) {
			$this->buf->add($this->ch);
			$this->advance();
		}
		$this->advance();
		return $this->createToken($this->buf->b, constants_TokenType::$String);
	}
	public function readDouble() {
		$tt = null;
		if($this->isAssign(null)) {
			$tt = constants_TokenType::$Assign;
		} else {
			if($this->isGte(null)) {
				$tt = constants_TokenType::$Gte;
			} else {
				if($this->isLte(null)) {
					$tt = constants_TokenType::$Lte;
				} else {
					if($this->isNeq(null)) {
						$tt = constants_TokenType::$Neq;
					}
				}
			}
		}
		if($tt === null) {
			return null;
		}
		$ch1 = $this->ch;
		$this->advance();
		$ch2 = $this->ch;
		$this->advance();
		return $this->createToken("" . _hx_string_or_null($ch1) . _hx_string_or_null($ch2), $tt);
	}
	public function readSingle() {
		$tt = constants_TokenType::$Any;
		$ch = $this->ch;
		if($this->isComma(null)) {
			$tt = constants_TokenType::$Comma;
		} else {
			if($this->isDot(null)) {
				$tt = constants_TokenType::$Dot;
			} else {
				if($this->isEq(null)) {
					$tt = constants_TokenType::$Eq;
				} else {
					if($this->isGt(null)) {
						$tt = constants_TokenType::$Gt;
					} else {
						if($this->isLt(null)) {
							$tt = constants_TokenType::$Lt;
						} else {
							if($this->isLb(null)) {
								$tt = constants_TokenType::$Lb;
							} else {
								if($this->isLf(null)) {
									$tt = constants_TokenType::$Nl;
								} else {
									if($this->isRb(null)) {
										$tt = constants_TokenType::$Rb;
									} else {
										if($this->isLp(null)) {
											$tt = constants_TokenType::$Lp;
										} else {
											if($this->isRp(null)) {
												$tt = constants_TokenType::$Rp;
											} else {
												if($this->isSquote(null)) {
													$tt = constants_TokenType::$Squote;
												} else {
													if($this->isPlus(null)) {
														$tt = constants_TokenType::$Plus;
													} else {
														if($this->isDash(null)) {
															$tt = constants_TokenType::$Minus;
														} else {
															if($this->isAst(null)) {
																$tt = constants_TokenType::$Times;
															} else {
																if($this->isFs(null)) {
																	$tt = constants_TokenType::$Divide;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		$this->advance();
		return $this->createToken($ch, $tt);
	}
	public function reset() {
		$this->buf = new StringBuf();
	}
	public function skipWhitespace() {
		if(!$this->isWhitespace(null)) {
			return;
		}
		while($this->isWhitespace(null)) {
			$this->advance();
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'parser.Tokenizer'; }
}
