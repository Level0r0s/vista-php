<?php

// Generated by Haxe 3.4.2
class runtime_functions_StdFunctions extends runtime_functions_ModuleFunctions {
	public function __construct($methodContext) { if(!php_Boot::$skip_constructor) {
		parent::__construct($methodContext);
	}}
	public function callMemberFunction($lit1, $lit2, $nargs) {
		$objectName = Std::string($this->literal($lit1));
		$functionName = Std::string($this->literal($lit2));
		$args = (new _hx_array(array()));
		{
			$_g1 = 0;
			$_g = $nargs;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$args->unshift($this->pop());
				unset($i);
			}
		}
		$this->callMemberFn($objectName, $functionName, $args);
		$this->push($functionName);
	}
	public function createNew($nameLit) {
		$className = Std::string($this->literal($nameLit));
		$module = $this->getModule($className);
		if($module === null) {
			$this->push("module " . _hx_string_or_null($className) . " not found");
		} else {
			$this->push($module->createInstance());
		}
	}
	public function dimension($moduleLit, $nameLit) {
		$module = Std::string($this->literal($moduleLit));
		$name = Std::string($this->literal($nameLit));
		$obj = runtime_proxies_ProxyManager::ensureProxy($module, $name, null);
		$this->push($this->queueCreation($obj));
	}
	public function dimensionAny($name) {
		return new runtime_proxies_QkObject($name);
	}
	public function dimensionDatabase($name) {
		return new runtime_proxies_QkObject($name);
	}
	public function divide() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		if($arg2 !== 0) {
			$this->push($arg1 / $arg2);
		} else {
			$this->push(0);
		}
	}
	public function eq() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 === $arg2);
	}
	public function gt() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 > $arg2);
	}
	public function gte() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 >= $arg2);
	}
	public function jmp($n) {
		$this->hgoto($this->pc + $n);
	}
	public function jmpIfFalse($n) {
		$val = $this->pop();
		if(!$val) {
			$this->hgoto($this->pc + $n);
		}
	}
	public function lt() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 < $arg2);
	}
	public function lte() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 <= $arg2);
	}
	public function minus() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 - $arg2);
	}
	public function neq() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 !== $arg2);
	}
	public function nop() {}
	public function plus() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 + $arg2);
	}
	public function popIntoGlobalVar($lit) {
		$name = Std::string($this->literal($lit));
		$val = $this->pop();
		$this->push($this->setGlobalVar($name, $val));
	}
	public function popIntoInstanceVar($lit) {
		$name = Std::string($this->literal($lit));
		$val = $this->pop();
		$this->push($this->setLocalVar($name, $val));
	}
	public function popIntoProperty($objectLit, $propertyLit) {
		$objectName = Std::string($this->literal($objectLit));
		$propertyName = Std::string($this->literal($propertyLit));
		$val = $this->pop();
		$this->push($this->setPropertyNames($objectName, $propertyName, $val));
	}
	public function pushGlobalVar($lit) {
		$name = Std::string($this->literal($lit));
		$this->push($this->getGlobalVar($name));
	}
	public function pushInstanceVar($lit) {
		$name = Std::string($this->literal($lit));
		$this->push($this->getLocalVar($name));
	}
	public function pushProperty($objectLit, $propertyLit) {
		$objectName = Std::string($this->literal($objectLit));
		$propertyName = Std::string($this->literal($propertyLit));
		$this->push($this->getPropertyNames($objectName, $propertyName));
	}
	public function subDefine($lit, $start) {
		$name = Std::string($this->literal($lit));
		$this->push($this->setGlobalVar($name, $start));
	}
	public function subReturn() {
		$target = $this->popReturn();
		$this->hgoto($target);
	}
	public function times() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 * $arg2);
	}
	function __toString() { return 'runtime.functions.StdFunctions'; }
}
