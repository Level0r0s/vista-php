<?php

// Generated by Haxe 3.4.2
class runtime_functions_StdFunctions extends runtime_functions_UiFunctions {
	public function __construct($methodContext) { if(!php_Boot::$skip_constructor) {
		parent::__construct($methodContext);
	}}
	public function callMemberFunction($lit1, $lit2, $nargs) {
		$objectName = Std::string($this->literal($lit1));
		$functionName = Std::string($this->literal($lit2));
		$args = (new _hx_array(array()));
		{
			$_g1 = 0;
			$_g = $nargs;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$args->unshift($this->pop());
				unset($i);
			}
		}
		$this->callMemberFn($objectName, $functionName, $args);
		$this->push($functionName);
	}
	public function dimension($lit, $type) {
		$name = Std::string($this->literal($lit));
		$obj = runtime_proxies_ProxyManager::ensureProxy($name, $type);
		$this->push($this->queueCreation($obj));
	}
	public function dimensionAny($name) {
		return new runtime_proxies_QkObject($name);
	}
	public function dimensionDatabase($name) {
		return new runtime_proxies_QkObject($name);
	}
	public function divide() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		if($arg2 !== 0) {
			$this->push($arg1 / $arg2);
		} else {
			$this->push(0);
		}
	}
	public function eq() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 === $arg2);
	}
	public function gt() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 > $arg2);
	}
	public function gte() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 >= $arg2);
	}
	public function jmp($n) {
		$this->hgoto($this->pc + $n);
	}
	public function jmpIfFalse($n) {
		$val = $this->pop();
		if(!$val) {
			$this->hgoto($this->pc + $n);
		}
	}
	public function lt() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 < $arg2);
	}
	public function lte() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 <= $arg2);
	}
	public function minus() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 - $arg2);
	}
	public function neq() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 !== $arg2);
	}
	public function nop() {}
	public function plus() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 + $arg2);
	}
	public function popIntoGlobal($lit) {
		$name = Std::string($this->literal($lit));
		$val = $this->pop();
		$this->push($this->setGlobalName($name, $val));
	}
	public function popIntoProperty($objectLit, $propertyLit) {
		$objectName = Std::string($this->literal($objectLit));
		$propertyName = Std::string($this->literal($propertyLit));
		$val = $this->pop();
		$this->push($this->setPropertyNames($objectName, $propertyName, $val));
	}
	public function pushGlobal($lit) {
		$name = Std::string($this->literal($lit));
		$this->push($this->getGlobalName($name));
	}
	public function pushProperty($objectLit, $propertyLit) {
		$objectName = Std::string($this->literal($objectLit));
		$propertyName = Std::string($this->literal($propertyLit));
		$this->push($this->getPropertyNames($objectName, $propertyName));
	}
	public function subDefine($lit, $start) {
		$name = Std::string($this->literal($lit));
		haxe_Log::trace("subDefine", _hx_anonymous(array("fileName" => "StdFunctions.hx", "lineNumber" => 128, "className" => "runtime.functions.StdFunctions", "methodName" => "subDefine", "customParams" => (new _hx_array(array($name))))));
		$this->push($this->setGlobalName($name, $start));
	}
	public function subReturn() {
		$target = $this->popReturn();
		$this->hgoto($target);
	}
	public function times() {
		$arg1 = $this->pop();
		$arg2 = $this->pop();
		$this->push($arg1 * $arg2);
	}
	function __toString() { return 'runtime.functions.StdFunctions'; }
}
