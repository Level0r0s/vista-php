<?php

// Generated by Haxe 3.4.2
class runtime_ProcessBase {
	public function __construct($bytecodes, $literals) {
		if(!php_Boot::$skip_constructor) {
		$this->bytecodes = $bytecodes;
		$this->index = 0;
		$this->iterations = 0;
		$this->literals = $literals;
		$this->output = (new _hx_array(array()));
		$this->returnStack = (new _hx_array(array()));
		$this->stack = (new _hx_array(array()));
	}}
	public $bytecodes;
	public $index;
	public $iterations;
	public $literals;
	public $output;
	public $returnStack;
	public $stack;
	public function actionOutput($object, $action, $args, $afterAppear = null) {
		if($afterAppear === null) {
			$afterAppear = false;
		}
		$payload = _hx_anonymous(array("service" => "action", "id" => $object->getId(), "action" => $action, "args" => $args, "afterAppear" => $afterAppear));
		$this->pushOutput($payload);
	}
	public function hgoto($n) {
		$this->index = $n;
	}
	public function literal($index) {
		return $this->literals[$index];
	}
	public function pop() {
		return $this->stack->pop();
	}
	public function popn($n) {
		$val = null;
		{
			$_g1 = 0;
			$_g = $n;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$val = $this->pop();
				unset($i);
			}
		}
		return $val;
	}
	public function popReturn() {
		return $this->returnStack->pop();
	}
	public function printOutput($msg) {
		$this->serviceOutput("print", _hx_anonymous(array("msg" => $msg)));
	}
	public function push($val) {
		$this->stack->push($val);
		return $val;
	}
	public function pushConst($lit) {
		return $this->push($this->literal($lit));
	}
	public function pushOutput($val) {
		$this->output->push($val);
	}
	public function pushReturn() {
		$this->returnStack->push($this->index);
	}
	public function serviceOutput($service, $args) {
		$payload = _hx_anonymous(array("service" => $service, "args" => $args));
		$this->pushOutput($payload);
	}
	public function stackSize() {
		return $this->stack->length;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'runtime.ProcessBase'; }
}
